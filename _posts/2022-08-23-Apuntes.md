---
layout: post
author: Robinson Molina
title: Apuntes Programacion
---
# Apuntes de Programación

## Linux

Para lenvantar un servidor 
> ifconfig 
ver las conexiones de internet
> iwlist
para listar todos los puntos de acceso detectados.
    
> iwconfig 
para configurar la conexión inalámbrica.

> dhclient 
para asignarle a nuestra compu una dirección IP a través de DHCP.

### intallar un .deb

sudo dpkg -i virtualbox-6.1_6.1.32-149290~Ubuntu~eoan_amd64.deb


como descargar y instalar programas con linea de comandos 

> $ sudo apt-get update
> $ wget // https://dl.winehq.org/wine/source/1.9/wine-1.9.19.tar.bz2// link
> $ sudo tar xzvf //wine-1.9.19.tar.bz2// Descargable
> $ cd //wine-1.9.19// Ingresar a la carpeta 
> $ ./configure
> $ make
> $ sudo make install
> $ sudo reboot
> $ nano archivo.txt // leer archivo

>ls //listar las carpetas y archivos
>	ls -la 	//Todos los archivos ocultos
>	ls -lS		//listar por tamaño de archivos
>	ls -lr		//listar al reves de z-a
>	ls nombre	//lista el contenido de adentro de directorio "nombre"

tree 	//listar de forma de raiz de arbol // es necesario instalar
> tree -L 2		//profundizar en 2 niveles "2" es modificable, "L" es de level

mkdir nombre	//crear directorio "nombre" es ha preferencia sin espacios
> mkdir nombre nombre2 nombre3	//crear multiples directorio

touch nombre 	//crear archivo con cualquier externo por defecto solo de texto
> touch nombre nombre1 nombre2	//crear multiples archivos

cp nombre	//crear una copia de archivo

mv nombre ubicacion		// mover archivos
-> mv nombre ..		// mueve para atras
-> mv nombre nombre_nuevo	// renombra el archivo

rm nombre 	//remueve y elimina archivos
-> rm -i		//remueve y elimina con confirmacion en el terminal "i" de interactividad
-> rm -r		//eliminar de manera recursiva para directorio
-> rm -rf		//elimina de manera recursiva y forzosa


df -h 	// esto permite ver todos los discos y particiones que tienes ser root

head nombre	//muestra la cabezera de texto, las 10 primeras lineas
-> head nombre -n 15		//"n" modifica la lineas que se veran

tail nombre	//muestralas ultimas lineas de texto
-> tail nombre -n 15		//"n" modifica la lineas que se veran

less nombre	//ver todo el archivo de la terminal
-<	/		//Metodo de busqueda
-<	u		//Para salir de la Vista

xdg-open nombre	//abrir archivo con aplicacion predeterminada
-<	ctrl+c			//matar proceso

nautilus nombre_directorio	//abrir ventanas para abrir directorios

UN COMANDO PUEDE SER
--programa ejecutable
--Un comando de utilidad de la Shell
--Una funcion de shell
--Un alias

type comando	//muestra que tipo de comando es

alias l="comando"	//configurar un alias temporal

help comando		//ayuda de comandos
-> comando --help 	//ayuda de comandos

man comando		//manual de comandos

info comando		//informacion de comando

whatis comando		//saber que hace el comando

WILDCARDS
*
ls *.txt	//lista todos los archivos con .txt
ls nombre*	//lista todos los archivo con el "nombre" al inicio
?
ls nombre?	//listar con considencia de 1, el caracter "?" 
	
ls [[:upper:]]*	//busca nombre con mayuscula a dos niveles de la carpetas
ls -d [[:upper:]]*	//lista solo los directorios con mayuscula
ls [[:lower:]]*	//lista solo los directorios con minusculas
ls [ad]*		//lista todos los archivos con "ad" es modificable que inicien con a y d
	
	
REDIRECCIONAMIENTO
	
>		//estandar output
	
ls nombre > archivo.txt	//crea uno nuevo y guarda lo que sale en consola
ls nombre >> archivo.txt	//crea y concatena con documento existe
		
2>		//estandar error
		  
  2> archivo.txt	//crea uno nuevo y guarda los errores de la consola
		  
<		//estandar input
ls nombre > output 2>&1 	//para guardar los estandar output y error

## Html

Etiquetas 
``` html
<a></a>
```
Para incuir un enlace
Atributos href="link_de_enlace"

Etiquetas 
``` html
<ul></ul>
```
Para crear un lista no ordenada



## FireBase

Implementar con el comando 
> firebase desploy

## Entorno anaconda
> $ conda create -n my_env35 python=3.10
> $ conda info --envs

To activate this environment, use

> $ conda activate openCV-python

 To deactivate an active environment, use

> $ conda deactivate
      
> $ conda install --name my_env35 numpy

> $ anaconda-navigator

Obtener el número de versión

> $ conda -V

Crea un entorno para especificar la versión de Python

> $ conda create --name your_env_name python=3.8

Enumere todos los entornos actuales

> $ conda info --envs
> $ conda env list

Entra en un entorno

> $ activate your_env_name

Salir del entorno actual

> $ deactivate

Enumere todos los paquetes en el entorno activo actual

> $ conda list

Eliminar un entorno
> $ conda env remove -n nombre_entorno

## C++

### HISTORIA
La historia del lenguaje de programación C++ comienza a principios de los años 70,con un programador de nombre Dennis Ritchie que trabajaba en los laboratorios de AT&T Bell.

En 1983, el Instituto Americano de Normalización (ANSI) se dio a la tarea de estandarizar el lenguaje C, aunque esta tarea tardó 6 años en completarse, y además con la ayuda de la Organización Internacional de Normalización (ISO), en el año de 1989 definió el C Estándar.

Fue en los mismos laboratorios de AT&T Bell, que Bjarnes Stroutstrup diseñó y desarrolló C++ buscando un lenguaje con las opciones de programación orientada a objetos.

> Lenguaje estructurado debemos pensar en funciones, y
también a sentencias de control (if, while, etc.)

Cuando se compila código C en un compilador C++ este debe cumplir con los estándares definidos en 1989, cualquier palabra definida en el estándar de 1999 no
funcionará.

En el estándar de C++ las bibliotecas dejan de utilizar el “.h”, es decir que en lugar de utilizar <iostream.h>, ahora tendrá que escribirse <iostream>, en vez de <iomanip.h> será <iomanip>. 

A pesar que esto tiene varias ventajas, que tal vez no vea en este momento, se tendría que colocar “std” antes de cada llamada a una función de la biblioteca, debido a que toda la biblioteca estándar de C++ está definida en el espacio de nombres llamado std. Con esto, tendríamos que hacer una llamada a escribir en pantalla con la instrucción std::cout.

Para evitar esto, y por consiguiente hacer menos extenso el código a escribir, podemos emplear la directriz using, indicando al compilador el espacio de nombres donde está referenciado.

#### Programa base C
``` c++
#include <iostream> //Declaración de librerias

int main(void) // función main 
{ 
    cout<< "Hola Mundo"<<endl; //secuencia de instruciones 
    return 0;  //valor retorno de la funcion main
}

```
#### Programa base C++
``` c++
#include <iostream> //Declaración de librerias
using namespace std; // usar Std donde necesite referencia
int main(void)// función main 
{
    cout<< “adios a todos” <<endl; //secuencia de instruciones 
    return 0; //valor retorno de la funcion main
}
```

#### Tipos de Datos
`Una variable es una posición de memoria` con nombre que se usa para mantener un valor que puede ser modificado por el programa3. Las variables son declaradas, usadas y liberadas. Una declaración se encuentra ligada a un tipo, a un nombre y a un valor.

> int variable = 6;  // Palabra_reservada Nombre = Valor

C++ es sensible a mayúsculas y minúsculas, así que si el nombre de nuestra variable empieza con una letra en mayúsculas, debemos de asegurarnos que durante el resto del código nos refiramos a ella exactamente como la escribimos. Los nombres de las variables no pueden usar signos de puntuación, `sólo caracteres “A-Z”, “a-z”, “_“, “0-9”, aunque ningún nombre debe comenzar con un número (0-9)`. Además no se deben de repetir nombres de variables en el mismo contexto.


> Se pueden asignar valores en formato octal y hexadecima
```c++
int variable1=022;
int variable2=0x12;
```

> También se pueden asignar números exponenciales
```c++
float variable3=2e-6;
```
El valor `(carácter)` que se almacena en una variable o constante de tipo char, es el valor entero del carácter en el juego de caracteres ASCII. 
```c++
char inicial=’A’
```

Variables son llamadas `locales`; en la definición de parámetros de una función, como se verá más adelante; y fuera de todas las funciones, variables `globales`.

```c++
#include <iostream.h>
using namespace std;

int variable_global=10;

int main(){
    int variable_local=20;

    return 0;
}
```
En un programa puede que necesitemos declarar un dato y asignarle un nombre, pero que éste no pueda ser modificado se lo llama constantes

```c++
const float pi=3.141592; // const tipo nombre = valor
```

##### Palabras reservadas

and | and_eq | asm | auto
bitand | bitor | bool | break
case | match |char | class
compl | const | const_cast | continue
default | delete | do | Double
dynamic_cast | else | enum | explicit
export | extern | false | float
for | friend | goto | if
inline | int | long | mutable
namespace | new | not | not_eq
operator | or | or_eq | private
protected | public | register | reinterpret_cast
return | short | signed | sizeof
static | static_cast | struct | switch
template | this | throw | true
try | typedef | typeid | typename
union | unsigned | using | virtual
void | volatile | wchar_t | while
xo | -- |-- |--

#### Carateres de control

Caracteres de control | Significado
\n | salto de línea
\t | tabulador horizontal
\v | tabulador vertical
\a | alerta sonora
\0 | carácter nulo
\b | mueve el cursor hacia atrás

#### Tipos de Datos

Tipo | Tamaño en bytes | Intervalo
short | 2 | -32768 a 32767
unsigned short | 2 | 0 a 65535
long | 4 | -2147483648 a 2147483647
unsigned long | 4 | 0 a 4294967295
int | podría ser 2 o 4 | -32768 a 32767
unsigned int | 2 o 4 | 0 a 65535
float| 4 | 1.17549535e-38 a 3.402823466e+38 con 8 cifras decimales
double | 8 | 2.2250738585072014e-308 a 1.7976931348623158e+308 con 16 cifras decimales
long double | 10 |--
char | 1  | -128 a 127
unsigned char | 1 | 0 a 255
bool| 1 |  Valor lógico o booleano verdadero o falso


En la biblioteca <limits.h> encontrará constantes definidas para los intervalos que pueden almacenar algunos tipos de variables. Compile y ejecute el siguiente programa, después consulte la biblioteca <limits.h> para ver más constantes definidas.

```c++
#include <limits.h>
using namespace std;
#include <iostream.h>

int main(void){
    cout<<"PROGRAMA QUE MUESTRA LOS VALORES MAXIMOS Y MINIMOS \n DE ALGUNOS DE LOS TIPOS DE DATOS "<<endl;
    cout<<"\n int maximo: "<<INT_MAX<<" int minimo: "\
    <<INT_MIN<<endl;
    cout<<"\n char maximo: "<<CHAR_MAX<<" char minimo: "\
    <<CHAR_MIN<<" tamaño en bits: "<<CHAR_BIT<<endl;
    cout<<"\n long maximo: "<<LONG_MAX<<" long minimo: "\
    <<LONG_MIN<<endl;
    cout<<"\n short maximo: "<<SHRT_MAX<<" short minimo: "\
    <<SHRT_MIN<<endl;
    return 0;
}
```

#### Operadores basicos 

Operador | Significado
+ | adición
- | sustracción
* | multiplicación
/ | división
% | resto de la división entera

> ++” y “--“. Éstos tienen la función de aumentar y disminuir en uno al dato que opera. 

#### Operadores de Desplazamiento

| << | Desplazamiento de bits a la izquierda
| >> | Desplazamiento de bits a la derecha

#### Operadores relacionales y de igualdad

Operador | Significado
< | menor que
<= | menor oigual
> | mayor que
>= | mayor oigual
== | igual
!= | desigual

#### Operadores de bits y lógicos
Operador |Significado
& |conjunción (Y) de bits
^ |(O) exclusivo de bits
| |(O) inclusivo de bits


#### Operador Significado
&& conjunción lógica (Y)
| | disyunción lógica (O)


#### Precedencia de operadores


Símbolo | Significado
:: | resolución de alcance
---|---
++ | incremento sufijo
-- | decremento sufijo
( ) | llamada a función
[ ] | elemento de tabla
-> | acceso a miembro desde un puntero
. | acceso a miembro
---|---
++ | incremento prefijo
-- | decremento prefijo
! | negación lógica
~ | complemento a uno
- | cambio de signo (operador unario)
+ | identidad (operador unario)
& | dirección
* | seguir un puntero
sizeof | tamaño en bytes
new | reserva de memoria
delete | liberación de memoria
(tipo) |conversión explícita de tipos

.*  | acceso a miembros de clase
->* | acceso a miembros de clase desde puntero
* | multiplicación
/ | división
% | resto de la división entera
+ | suma
- | resta 
<< | desplazamiento de bits a la izquierda
>> | desplazamiento de bits a la derecha
< | menor que
<= |menor o igual
> | mayor que
>= | mayor o igual
== | igual
!= | desigual
& | conjunción (Y) de bits
^ | O exclusivo de bits
| | O inclusivo de bits
&& | conjunción (Y) lógica
| | |disyunción (O) lógica
= | asignación simple
*=, /=, %=, +=, - =, <<=, >>=,&=, ^=, |= |asignaciones compuestas
?: | expresión condicional
trhow | Lanzamiento de excepción
,| separador de expresiones


### Entrada y Salida

Con `cout` Estamos enviando una cadena de caracteres (“Mensaje a la pantalla”) al dispositivo de salida estándar (la pantalla). Luego, el manipulador de flujo endl da el efecto de la secuencia de escape ‘\n’.

> cout<<"Mensaje de pantalla"<< endl;

`cin` es el flujo de entrada asociado al teclado, cout es el flujo de salida estándar asociado a la pantalla, y existe otro

> cin>>otroNumero;

`cerr`, que es el flujo de error estándar asociado a la pantalla.

Transformar salida `(tipo)(dato)`
A esto se le llama hacer un `cast`, y es muy común hacerlo cuando no queremos que
se pierdan determinadas propiedades en los resultados de las operaciones.

> cout<<(int)(3.141592+2)<< endl; // Transformar a entero

Otra de las herramientas para la especificación de formatos son los manipuladores de flujos, así como el manipulador de flujo `“endl”` da una secuencia de escape, los manipuladores `dec, oct y hex`, hacen que la variable a la que le anteceden sea presentada en formato decimal, octal o hexadecimal respectivamente.

```c++
#include <iostream.h>
int main(){
int numero=6;
int leido;
cout<<"numero es en octal: "<<oct<<numero<<endl;
cout<<"en hexadecimal: "<<hex<<numero<<endl;
cout<<"en decimal: "<<dec<<numero<<endl;
cout<<"ahora teclea un numero"<<endl;
cin>>hex>>leido;
cout<<"el leido vale: "<<hex<<leido<<endl;
cout<<"y en decimal: "<<dec<<leido<<endl;
cout<<"y en octal: "<<oct<<leido<<endl;
return 0;
}
```

> Imprimir en pantalla un número de tipo flotante, sólo aparecerán 6 números después del punto, y la
ultima cifra será redondeada en caso de pasar los 6 dígitos.

Cuando se quieren resultados más exactos, nos es muy útil la librería `iomanip.h` que contiene el manipulador setprecision() con el que podemos determinar la precisión con la que queremos que aparezcan esos datos en la pantalla.

`setw` que se encarga de hacer aparecer el texto alineado determinados espacios a la derecha, si el numero de espacios solicitados para su alineación es menor que el numero de caracteres que se imprimirán, no tendrá un efecto.

`setfill` se ocupa del carácter de relleno, el carácter por defecto es el espacio en
blanco, pero nosotros podemos especificar el que queramos.

```c++
#include <iostream.h>
#include <iomanip.h>
int main(){
cout<<setw(5)<<setfill('%')<<"hola"<<endl;
cout<<setw(5)<<89;
cout<<setw(8)<<"centavo"<<endl;
return 0;
}
```
get
getline
read
write
ignore
gcount

```c++
#include <iostream.h>
    int main(){
    char caracter,nombre[20], apellido[20];
    char seg_apellido[20];
    cout<<"Teclea tu nombre por favor"<<endl;
    cin.get(caracter);
    cin.get(nombre,20,' ');
    cin.get();
    cin.get(apellido,20,' ');
    cin.get();
    cin.get(seg_apellido,20);
    cout<<caracter<<"Tu letra inicial es:"<<caracter<<endl;
    cout<<"tu nombre es: "<<caracter<<nombre<<endl;
    cout<<"tu apellido paterno es: "<<apellido<<endl;
    cout<<"tu apellido materno es: "<<seg_apellido<<endl;
    cout<<"Escribe el nombre de tu empresa: "<<endl;
    cin.ignore();
    cin.getline(nombre,20);
    cout<<"el nombre de tu empresa: "<<nombre<<" tiene "
    <<cin.gcount()<<" caracteres"<<endl;
    cin.get();
    //espera que oprimas enter para terminar
    return 0;
}
```

### Estructuras de Control


#### if
Se trata de una estructura de selección. Es decir que si se cumple el condicional se ejecutarán varias instrucciones más. Podemos añadir un else a la sentencia if, de manera que controlamos las opciones en caso de que la condición resulte false.

> if(condicion){caso verdadero;} else{caso falso;}

```c++
    if((examen[0]=='s')&&(semestre[0]=='s')){
        cout<<"estas en la universidad"<<endl;
    }
    else{
        cout<<"no estas en la universidad"<<endl;
    }
```

#### ? :
Este se trata de un operador del tipo condicional al estilo if/else. Se utiliza para condicionales cortos (de una sola línea).

> condición ? acción a ejecutar en caso verdadero : acción a ejecutar en caso falso ;

```c++
#include <iostream.h>
int main(){
    int calificacion;
    cout<<"Cual fue tu calificacion del semestre?"<<endl;
    cin>>calificacion;
    cout<<(calificacion>=6 ? "pasaste" : "reprobaste");
    cin.ignore();
    cin.get();
    return 0;
}
```
#### Switch

La estructura de selección múltiple switch, cuando hay muchas opciones que pudiese tomar el usuario

switch (parámetro a evaluar o comparar){
    case a : //cuando el parámetro tiene un valor a
        Acciones a ejecutar;
    case b: //cuando el parámetro tiene un valor b
        Acciones a ejecutar
    caso por default;
}


```c++
#include <iostream.h>
int main(){
    int opcion;
    cout<<"Menu de opciones"<<endl;
    cout<<"1.­ Opcion 1"<<endl;
    cout<<"2.­ Opcion 2"<<endl;
    cout<<"3.­ Opcion 3"<<endl;
    cout<<"elige una opcion"<<endl;
    cin>>opcion;
    switch(opcion){
        case 1:
            cout<<"ejecucion 1"<<endl;
            break;
        case 2:
            cout<<"ejecucion 2"<<endl;
            break;
        case 3:
            cout<<"ejecucion 3"<<endl;
            break;
        default:
            cout<<"es una opcion no valida"<<endl;
            break;
    }
    cout<<"presiona enter para salir"<<endl;
    cin.ignore();
    cin.get();
    return 0;
}
```

#### while

La sentencia de control while se encarga de repetir un bloque de código mientras se cumpla una condición. El bloque de código se debe de encontrar entre llaves,
excepto si es una sola línea.

> while (condición) {acciones a ejecutar;}

```c++
#include <iostream.h>
int main(){
    int calificacion, suma=0, iteracion=1;
    float promedio;
    while(iteracion<=10){
        cout<<"teclea tu calificacion "<<iteracion<<endl;
        cin>>calificacion;
        suma+=calificacion;
        ++iteracion;
    }
    promedio=(float)suma/(iteracion­1);
    cout<<"el promedio de calificaciones es: " <<promedio<<endl;
    cin.ignore();
    cin.get();
    return 0;
}
```
#### do while
Cuando necesitamos que un ciclo se ejecute por lo menos una vez, es necesaria esta sentencia.

> do{ Acciones a ejecutar; } while(condicion);

```c++
#include <iostream.h>
int main(){
    int opcion;
    do{
        cout<<"elije una opcion de la lista"<<endl;
        cout<<"1.­opcion 1"<<endl;
        cout<<"2.­opcion 2"<<endl;
        cout<<"3.­opcion 3"<<endl;
        cin>>opcion;
    }while((opcion<1)||(opcion>3));
    cout<<"esta opcion si fue valida"<<endl;
    cin.ignore();
    cin.get();
    return 0;
}
```

#### for
El ciclo for es al que más se recurre cuando se requiere realizar operaciones secuenciales, en donde se conoce el número de iteraciones o la condición a
comprobar.


> for(asignación inicial ; condición ; instrucción ) { bloque de instrucciones; }
ó, si se trata de una instrucción muy corta podría ponerse:

> for(asignación inicial ; condicion ; instrucción1 , instrucción 2)
```c++
#include <iostream.h>
#include <math.h> // libreia de matematica
int main (){
    int t;
    float x=0,y=0,ang,vi, grav=9.81;
    cout<<"cual es el angulo de lanzamiento?"<<endl;
    cin>>ang;
    cout<<"cual es la velocidad inicial?"<<endl;
    cin>>vi;
    ang=((ang*3.141592)/180); //necesario convertir a radianes
    for(t=0;t<=10;t++){
        x=(vi*cos(ang)*t);
        y=(vi*sin(ang)*t)­(0.5*grav*t*t);
        
        cout<<"t= "<<t<<" x= "<<x<<" y= "<<y<<endl;
    }
    cout<<"fin del programa"<<endl;
    cin.ignore();
    cin.get();
    return (0);
}
```

### Funciones

Cuando tratamos de resolver un problema, resulta muy útil utilizar la filosofía de “divide y vencerás”. Esta estrategia consiste en dividir nuestro problema en otros más sencillos.

#### PROTOTIPOS
El prototipo de una función se refiere a la información contenida en la declaración de una función. Una función debe de estar definida o al menos declarada antes de hacer uso de ella.

Cuando se declara una función debe de especificarse el tipo de dato que va a devolver, el nombre de la función, y los parámetros.

> int suma(int a, int b);
> int main ( int argc, char *argv[], char *envp[]);


#### PASO DE ARGUMENTOS
Cuando hablamos de argumentos, nos referimos a los valores que aparecen en la llamada a la función.

> suma(dato1, dato2)

>> Notemos que el prototipo de la función pueden los nombres de los parámetros distintos a los de la prototipo, esto no afectará el comportamiento del programa, pero se vería mejor si fueran iguales. Lo que no puede cambiar es el tipo de datos que va a recibir.

#### VALORES DE RETORNO
Una función puede regresar cualquier tipo de valor excepto tablas u otras funciones.

#### MACROS
Una macro es una parte del código que puede parecer y actuar como una función, se define después de las librerías mediante un #define.

Se denominan instrucciones de preproceso, porque se ejecutan al comienzo de la compilación.

Sin embargo, no hay que abusar de ellas, porque podrían entorpecer el código y hacer lento el programa.

```c++
#include <iostream.h>
#define mayor(a,b) (a>b)? a: b //Macros

int main(){
    int a,b;
    cout<<"teclea 2 numeros distintos"<<endl;
    cin>>a;
    cin>>b;
    cout<<"el mayor de esos numeros es: " <<(mayor(a,b))<<endl;
    cin.ignore();
    cin.get();
    return 0;
}
```

>> Debemos tener cuidado si vamos a usar macros, las macros, al compilar el programa, se sustituyen directamente en donde se invocan, es decir, que en este ejemplo, es como si se introdujera directamente los condicionales dentro del cout.

//    #define curva(a) 1+2*a+a*a
si en nuestro código colocamos una instrucción
//    curva(1+3)
se sustituye por
//    1+2*1+3+1+3*1+3

>> En el lenguaje C, se acostumbra usar macros para definir constantes (porque a diferencia de C++, ahí no existe el tipo const.
> #define PI 3.141592

#### RECURSIVIDAD
La recursividad se presenta cuando una función se invoca a si misma. Distintamente a las iteraciones (bucles), las funciones recursivas consumen muchos recursos de memoria y tiempo.

```c++
#include <iostream.h>
long factorial(long numero); //prototipo
int main(){
    long numero;
    cout<<"número para calcular el factorial:"<<endl;
    cin>>numero;
    cout<<"el factorial es: "<<factorial(numero)<<endl;
    cin.ignore();
    cin.get();
    return 0;
}
// Funcion
long factorial(long numero){
    if(numero<=1)
    return 1;
    else
    return numero*factorial(numero­1);
}
```

>> La recursividad es un tema importante en el mundo de la programación, la utilidad de este tipo de funciones se aprovecha en el diseño de algoritmos de criptografía, de búsqueda, entre otros.

### Arrays

Cuando declaramos una variable estamos apartando en memoria espacio para guardar sus posibles valores dependiendo del tipo de dato que se trata. Un array o arreglo son una serie de localidades en memoria consecutivas que están asignadas a un solo nombre y un mismo tipo de datos.

|-- |Valor almacenado | Localidad en memoria
|Arreglo[0] | 60 | FFFB
|Arreglo[1] | 1550 | FFFC
|Arreglo[2] | 130 | FFFD
|Arreglo[3] | 45 | FFFE
|Arreglo[4] | 90 | FFFF


#### DECLARACIÓN
La forma de declarar un arreglo de cualquier tipo de datos es la siguiente:

> tipo nombre [tamaño] ;

#### ASIGNACIÓN DE VALORES
Al momento de declarar un arreglo de cualquier tipo, podemos inicializarlo con los valores que queramos. Para inicializar un arreglo de enteros:
> int MiArreglo[5] ={2,34,78,1,9};

``` C++
#include <iostream.h>
#include <iomanip.h> //para presentacion con formato
#include <stdlib.h>
#include <time.h>
int main(){
    const int tam_max=20;
    int aleatorios[tam_max];
    int i,suma=0;
    float promedio;
    srand((unsigned)time(NULL));
    for(i=0;i<tam_max;i++){
        aleatorios[i]=rand()%128;  // rand() genera numero aleatorio
        //asigna el numero
        cout<<"aleatorio generado: "
        //presenta el numero
        <<setw(5)<<aleatorios[i]<<endl;
    }
    for(i=0;i<tam_max;){
        suma+=aleatorios[i++]; //suma los elementos
    }
    
    promedio=(float)suma/tam_max;
    cout<<endl<<"el promedio es: "<<promedio<<endl;
    cin.get();
    return 0;
}
```

#### Paso de arreglo a funcion  
En el caso del paso de arreglos, este no se hace por valor, sino que se hace un paso por referencia simulado. Cuando se declara un arreglo, el nombre de éste es una variable que apunta al primer elemento del arreglo, es decir que contiene su dirección en memoria

> tipoRetorno MiFuncion (tipoArreglo nombre [ ] );

>> Cuando pasamos esta dirección a una función, cualquier modificación que se haga dentro de esa función de nuestro arreglo tendrá efectos en la variable original.

En ocasiones puede resultar poco conveniente que alguna de las funciones que
reciben un arreglo tenga derecho a modificarlo. Para eso podemos incluir el calificador `const` dentro del prototipo y definición de la función, de esta manera no podrá modificarse nada de este arreglo.

> tipoRetorno nombreFuncion (const tipoArreglo nombre [ ] );

#### ARREGLOS MULTIDIMENSIONALES
	
Como sabemos, se pueden crear arreglos de cualquier tipo de datos, también se pueden crear arreglos de arreglos. La forma de declararlos es con múltiples subíndices, cuantos se quieran tener, nosotros trabajaremos a lo más con dobles subíndices.

> tipoArreglo nombre [subíndice1] [subíndice2] ;
> Array1 [2] [3] = {1, 2, 3, 4, 5, 6};
> Array2 [2] [3] = {{2, 4, 6}, {8, 10, 12}};

```c++ 
#include <iostream.h>
#include <iomanip.h>
#include <stdlib.h>
#include <time.h>

const int vendedores=5, meses=4;
//Prototipos
void inicializa(int ventas[][meses]);
void calculaTotal(const int ventas[][meses]); // array no modificable

int main(){
    int ventas[vendedores][meses];
    int i;
    //Las siguientes instrucciones solo presentan un
    //
    encabezado para la tabla
    cout<<"ventas:"<<setw(23);
    for(i=1;i<=meses;++i)
    cout<<"
    mes"<<i;
    cout<<endl;
    //fin de encabezado
    inicializa(ventas);
    calculaTotal(ventas);
    cout<<endl<<endl<<"presiona enter para terminar"<<endl;
    cin.get();
    return 0;
}

// Funciones
void inicializa(int ventas[][meses]){
    int i,j;
    //contadores
    srand((unsigned)time(NULL));
    for(i=0;i<vendedores;++i){
        cout<<"ventas del vendedor "<<i+1<<": ";
        for(j=0;j<meses;++j){
            ventas[i][j]=rand()%50;
            cout<<setw(7)<<ventas[i][j];
        }
    cout<<endl;
    }
}
void calculaTotal(const int ventas[][meses]){
    int suma=0,total=0,i,j;
    cout<<endl<<endl;
    for(i=0;i<vendedores;++i){
        suma=0;
        for(j=0;j<meses;++j){
            suma+=ventas[i][j];
            }
        cout<<"el vendedor "<<i+1<<" vendio " <<suma<<" productos"<<endl;
        total+=suma;
    }
    cout<<endl<<endl<<"en total se vendieron: "
    <<total<<" productos en "<<meses<<" meses"<<endl;
}

```

### Apuntadores

Un apuntador se define como una variable que contiene una dirección de memoria. Para declarar un apuntador se hace uso del operador desreferencia o indirección (*), no se debe confundir con la multiplicación

> tipo *nombre;
> int *MiApuntador;

```c++
int MiVariable=20;
int *MiApuntador;
MiApuntador = &MiVariable;
```

Así “MiApuntador” contendrá la dirección de “MiVariable”.
#### Aritmetica de operadores & *
Quizá ya se dio cuenta, así como la multiplicación es el inverso de la división, en el caso de los apuntadores sucede algo parecido, si se coloca una instrucción como la que sigue:
> cout<< “la variable contiene ” <<&*variable;
o
> cout<< “la variable contiene ” <<*&variable;

tendrán el mismo resultado que si no se colocaran los operadores * y &.

```c++
#include<conio.h>
#include<stdlib.h>
#include<iostream.h>
#include<time.h>
int main(){
    int cont=0,i=0,num_aleat=0;
    char car;
    char *cadena[6]={"cinco","siete","texto","poema","radio","raton"};
    while(car!=27){
        srand((unsigned)time(NULL));
        num_aleat=rand()%6;
        cout<<endl<<endl<<cadena[num_aleat]<<endl;
        for(cont=0,i=0;(cont<100000)&&(cadena[num_aleat][i]!='\0');++cont){
            if(kbhit()){ // encagada de detectar si oprime una tecla 
                car=getch(); // lee y guarda en la variable el caracter
                if(car==cadena[num_aleat][i]){
                    cout<<car;
                    ++i;
                }
                fflush(stdin);// limpia el flujo de entrada
            }
        }
    }
    cout<<endl<<"juego terminado"<<endl;
    cin.get();
    return 0;
}
```

#### PASO DE ARGUMENTOS POR REFERENCIA

El paso por referencia consiste en pasar la dirección en memoria que ocupa esa variable para que la función que la recibe pueda hacer uso de ella, sin necesidad de
hacer una copia como ocurre con el paso por valor.

Para mandar la dirección es necesario utilizar el operador & dentro de la invocación a
la función. Y el prototipo y definición de la función debe especificar que será un
apuntador mediante el uso del *.

>tipo_que_regresa nombre_funcion (tipo_apuntador *nombre, otro_tipo nombre, …);

Lo anterior es la forma de una definición que hace uso de apuntadores. La función puede devolver o no un valor mediante una instrucción return(). Puede contener varios parámetros apuntador o no apuntador.

Cuando se va a hacer uso de esa función, la invocación es de la siguiente forma:
> nombre_funcion (&nombre, …);

En el caso de los arreglos recordemos que estos son la dirección, y no es necesario poner el operador &.
> nombre_funcion (arreglo[numero_cadena]);

```c++
#include<iostream.h>
void aMayusculas(char *cadena);
void cambiaNum(int *numero);
int main(){
    char palabra[10];
    int numero;
    cout<<"teclea una cadena "<<endl;
    cin.getline(palabra,10);
    aMayusculas(palabra);
    cout<<endl<<palabra<<endl;
    cout<<"ahora teclea un numero"<<endl;
    cin>>numero;
    cambiaNum(&numero);
    cout<<"este numero se cambio a: "<<numero;
    cin.ignore();
    cin.get();
    return 0;
}
void aMayusculas(char *cadena){
    for(int i=0;cadena[i]!='\0';++i)
        cadena[i]+=('A'­'a');
}
void cambiaNum(int *numero){
    *numero *= *numero;
}
```

### Estructuras

#### ENUMERACIONES

En ocasiones habremos de declarar constantes enteras una tras otra con valores consecutivos, por ejemplo:
>
Para evitar este tipo de declaraciones una tras otra, existe el tipo enumerativo. La declaración anterior se puede hacer de una mejor forma:
> enum {a,b,c,d};

Una enumeración puede ser global o local. Además de que puede tener un nombre que los identifique, podemos indicar desde donde empieza la numeración.

>enum meses { enero=1, febrero, marzo, abril, mayo, junio, julio, agosto, septiembre, octubre, noviembre, diciembre};

#### UNIONES
El tipo de datos union puede contener datos de tipos y tamaños diferentes, esta variable almacenará cualquier tipo de dato en una única localidad en memoria. 

```c++
union edificio{
    int habitaciones;
    int despachos;
    char empresa[10];
};
```
declara un nuevo tipo de dato llamado “edificio”, para usar una variable de tipo edificio bastará con hacer una declaración como:

> edificio casa;

Para accesar a los miembros de una variable de tipo union es necesario utilizar el operador punto (.), seguido de la variable a extraer. En este ejemplo hemos extraído un entero de la variable “casa” por medio de casa.habitaciones, si se hace una extracción como casa.empresa no sabemos exactamente que es lo que aparecerá porque pueden existir otros datos en esa área de la memoria asignada a esta cadena;

#### ESTRUCTURAS
Las estructuras son colecciones de elementos, los cuales pueden ser de diferente tipo, y a diferencia de las uniones, en éstas no se comparte la misma área de
memoria para los elementos.

La forma de declarar una estructura es más o menos como sigue:
```c++
struct nombre_estructura{
tipo nombre_elemento1;
tipo nombre_elemento2;
};
```

Es entonces cuando podemos declarar una variable del tipo de la estructura, funcionando el nombre de la estructura como un nuevo tipo de datos, de esta manera, la nueva variable tendrá cada uno de los elementos declarados en ella.

>nombre_estructura nueva_variable;

Para acceder a cada uno de sus elementos usamos el operador punto (.), seguido del nombre del nombre del elemento, de la misma forma que con las uniones.

>> Una estructura puede ser declarada de forma global o local, pero es más común hacerlo fuera de toda función.

```c++
#include<iostream.h>
#include<math.h>
struct proyectil{
    float VelocidadInicial, angulo;
    float PosX, PosY;
};
float calculaCaida(proyectil cosa);
int main(){
    proyectil misil;
    misil.PosX=misil.PosY=0;
    float distancia;
    cout<<"Este programa calculará la distancia, en linea\
    recta,en la que caerá un proyectil"<<endl;
    cout<<"escribe la velocidad inicial para lanzarlo: ";
    cin>>misil.VelocidadInicial;
    cout<<"escribe ahora el angulo de lanzamiento: ";
    cin>>misil.angulo;
    //distancia=calculaCaida(misil);
    distancia=calculaCaidaApuntador(misil);
    cout<<"la distancia a la que caerá el proyectil es: " <<distancia<<" metros aproximadamente"<<endl;
    cin.ignore();
    cin.get();
    return 0;
}
float calculaCaida(proyectil& cosa){
    int t=1;
    //tiempo
    const float grav=9.81; //gravedad
    cosa.angulo/=57.2957;
    //transformamos a radianes
    do{
        cosa.PosX=(cosa.VelocidadInicial*cos(cosa.angulo)*t);
        cosa.PosY=(cosa.VelocidadInicial*sin(cosa.angulo)*t)-­(0.5*grav*t*t);
        ++t;
    }while(cosa.PosY>0);
    return(cosa.PosX);
}
// uso de operador flecha
float calculaCaidaApuntador(proyectil cosa){
    int t=1; //tiempo
    const float grav=9.81; //gravedad
    cosa-> angulo/=57.2957; //transformamos a radianes
    do{
        cosa->PosX=(cosa->VelocidadInicial*cos(cosa->angulo)*t);
        cosa->PosY=(cosa->VelocidadInicial*sin(cosa->angulo)*t)-(0.5*grav*t*t);
        ++t;
    }while(cosa->PosY>0);
    return(cosa->PosX);
}
```

###  Entradas y Saliddas por archivo

#### MEMORIA DINÁMICA
Hasta el momento no contamos con una forma de “administrar” la memoria utilizada en nuestros programas, cuando declaramos una variable se asigna memoria para almacenar datos dentro de ella, y ésta no se destruye hasta que termina el bloque en el que fue declarada, se crea y se destruye cada que se pasa por ese bloque, quizá puede parecer poco importante, pero cuando se cuentan con grandes cantidades de datos, es necesario tener un mejor control de lo que se pone en memoria.

Una de las formas en que podemos asegurarnos que una variable declarada dentro de un bloque no sea borrada al término de éste, es mediante la utilización del
calificador `static`. De ésta manera, la variable perdurará hasta el término de todo el programa.

> static tipo_variable mi_variable;

Pero en algunos casos esto nos será insuficiente, vamos a necesitar “destruir” variables antes de terminar el programa, para hacer esto contamos con los operadores `new y delete`.

```c++
#include<iostream.h>
#include<iomanip.h>
const int NumMaterias=11;
struct alumno {
    int boleta, semestre;
    int calificaciones[NumMaterias];
    void constancia(alumno * este){
        cout<<"constancia impresa"<<endl;
        cout<<"alumno con boleta: "<<este­>boleta;
        cout<<setw(50)<<"del semestre numero: "
        <<este­>semestre<<endl;
        cout<<"\nCALIFICACIONES DEL SEMESTRE: "<<endl;
        for(int i=0;i<NumMaterias;++i){
            cout<<"asignatura "<<i+1<<" : "
            <<este­>calificaciones[i]<<endl;
        }
    }
    void inicia(alumno * este){
        for(int i=0;i<NumMaterias;++i)
            este­>calificaciones[i]=0;
        este­>boleta=0;
        este­>semestre=0;
    }
};
int main(){
    alumno *alan =new alumno;
    alan­>inicia(alan);
    cout<<"alan creado"<<endl;
    alan­>boleta=2005630170;
    alan­>semestre=5;
    alan­>constancia(alan);
    delete alan;
    alumno *alfonse=new alumno;
    alfonse­>inicia(alfonse);
    alfonse­>constancia(alfonse);
    delete alfonse;
    alan­>constancia(alan);
    cin.get();
    return 0;
}
```
#### Archivos

Para poder trabajar los ficheros como flujos es necesario incluir la librería `fstream.h`, y según la utilización que queramos dar a este fichero (lectura o escritura) deberemos declarar el tipo de flujo.

Para crear un archivo de salida declaramos una variable de tipo `ofstream`, el cual ya está declarado dentro de nuestra librería. Es mejor ver un ejemplo de base.

```c++
#include<fstream.h>
int main(){
    ofstream archivo;
    archivo.open("miarchivo.txt");
    archivo<<"hola desde este archivo\n";
    archivo<<"ya he escrito algo\n";
    archivo.close();
}
```

Tanto la primera como la segunda forma admiten un segundo argumento que especifica el modo de apertura de un archivo. Los modos disponibles se muestran en la siguiente tabla y pueden ser utilizados incluyendo la librería iostream.h.

|ios::app | Se escribe al final de archivo
|ios::out | El archivo se abre para escritura
|ios::trunc | Si el archivo existe se eliminará su contenido
|ios::in | El archivo se abre para lectura, el archivo original no será modificado
|ios::binary | El archivo se abre en modo binario


```c++
#include<iostream.h>
#include<fstream.h>
int main(){
ofstream archivo("miarchivo.txt", ios::app);
archivo<<"hola desde este archivo de nuevo\n";
archivo<<"ya he escrito algo de nuevo\n";
archivo.close();
}
```

```c++
#include<iostream.h>
#include<fstream.h>
int main(){
char caracter;
ifstream archivo("miarchivo.txt", ios::in);
while(!archivo.eof()){
archivo.get(caracter);
cout<<caracter;
}
archivo.close();
}
```

Además de éstas, existen otras funciones que nos serán muy útiles para que no sea tan secuencial la forma en la que leemos o escribimos el archivo.

|tellg() | Devuelve la posición de lectura 
|seekg() | Se coloca dentro del flujo en la posición pasada como
argumento para poder leer.
|tellp() | Devuelve la posición de escritura
|seekp() | Se coloca dentro del flujo en la posición pasada como
argumento para poder escribir.

## Python
=======
## Javascript

### Programacion
La programación es el acto de construir un programa—un conjunto de instrucciones precisas que le dicen a una computadora qué hacer. Porque las computadoras son bestias tontas y pedantes, la programación es fundamentalmente tediosa y frustrante.
### Valores, tipos y Operadores

#### Valores 
Para crear un valor, solo debemos de invocar su nombre. Esto es conveniente. No tenemos que recopilar materiales de construcción para nuestros valores, o pagar por ellos. Solo llamamos su nombre, y woosh
#### Numeros
Para una cantidad de N dígitos decimales, la cantidad de números que pueden ser representados es 10^n. Del mismo modo, dados 64 dígitos binarios, podemos representar 2^64 números diferentes, lo que es alrededor de 18 mil trillones (un 18 con 18 ceros más).
#### Números especiales

Existen 3 valores especiales en JavaScript que son considerados números pero que no se comportan como números normales.

Los primeros dos son Infinity y -Infinity, los cuales representan las infinidades positivas y negativas. Infinity - 1 aun es Infinity, y asi sucesivamente.

A pesar de esto, no confíes mucho en computaciones que dependan de infinidades. Estas no son matemáticamente confiables, y puede que muy rápidamente nos resulten en el próximo número especial: NaN.

NaN significa “no es un número” (“Not A Number”), aunque sea un valor del tipo numérico.


#### Strings
El próximo tipo de dato básico es el string. Los Strings son usados para representar texto. Son escritos encerrando su contenido en comillas:

>`Debajo en el mar`
>"Descansa en el océano"
>'Flota en el océano'

Los Newlines (los caracteres que obtienes cuando presionas la tecla de Enter) solo pueden ser incluidos cuando el string está encapsulado con comillas invertidas (\‘).

Para hacer posible incluir tales caracteres en un string, la siguiente notación es utilizada: cuando una barra invertida (\) es encontrada dentro de un texto entre comillas, indica que el carácter que le sigue tiene un significado especial.

Esto se conoce como escapar el carácter. Una comilla que es precedida por una barra invertida no representará el final del string sino que formara parte del mismo. Cuando el carácter n es precedido por una barra invertida, este se interpreta como un Newline (salto de linea). De la mima forma, t después de una barra invertida, se interpreta como un character de tabulación. 

Asi es como el string “Un carácter de salto de linea es escrito así: "\n".” puede ser expresado:

> Un carácter de salto de linea es escrito así: \"\\n\"."

Y eso es lo que hace JavaScript. Pero hay una complicación: La repre sentación de JavaScript usa 16 bits por cada elemento string, en el cual caben 2^16 números diferentes. Pero Unicode define mas caracteres que aquellos aproximadamente el doble, en este momento. 

Entonces algunos caracteres, como muchos emojis, necesitan ocupar dos “posiciones de caracteres” en losstrings de JavaScript.

Los strings no pueden ser divididos, multiplicados, o substraidos, pero el operador + puede ser utilizado en ellos. No los agrega, sino que los `concatena` pega dos strings juntos.

Los strings de comillas inversas, usualmente llamados
plantillas literales, pueden realizar algunos trucos más. Mas alla de permitir saltos de lineas, pueden también incrustar otros valores.
> `la mitad de 100 es ${100 / 2}`
Cuando escribes algo dentro de ${} en una plantilla literal, el resultado será computado, convertido a string, e incluido en esa posición. El ejemplo anterior produce “la mitad de 100 es 50”.

La forma en la que los strings son ordenados, es aproximadamente alfabético, aunque no realmente de la misma forma que esperaríamos ver en un diccionario: las letras mayúsculas son siempre “menores que” las letras minúsculas, así que "Z" < "a", y caracteres no alfabéticos (como !, - y demás) son también incluidos en el ordenamiento. Cuando comparamos strings, JavaScript evalúa los caracteres de izquierda a derecha, comparando los códigos Unicode uno por
uno.

#### Operadores unarios
No todo los operadores son simbolos. Algunos se escriben como palabras. Un ejemplo es el operador typeof, que produce un string con el nombre del tipo de valor que le demos.

```js
console.log(typeof 4.5)
// → number
console.log(typeof "x")
// → string
```

Los operadores que usan dos valores son llamados `operadores binarios`, mientras que aquellos operadores que usan uno son llamados `operadores unarios`. El operador menos puede ser usado tanto como un operador binario o como un operador unario.

Los signos > y < son tradicionalmente símbolos para “mayor que” y “menor que”, respectivamente. Ambos son operadores binarios.

#### Valores Booleanos
Es frecuentemente util tener un valor que distingue entre solo dos posibilidades, como “si”, y “no”, o “encendido” y “apagado”. Para este propósito, JavaScript tiene el tipo Boolean, que tiene solo dos valores: true (verdadero) y false (falso) que se escriben de la misma forma.

> operadores similares son >= (mayor o igual que), <= (menor o igual que), == (igual a), y != (no igual a).

>Solo hay un valor en JavaScript que no es igual a si mismo, y este es NaN (“no es un número”).
```js
console.log(NaN == NaN)
// → false
```

Se supone que NaN denota el resultado de una computación sin sentido, y como tal, no es igual al resultado de ninguna otra computación sin sentido.

#### Operadores Logicos 
El operador && representa el operador lógico and. Es un operador binario, y su resultado es verdadero solo si ambos de los valores dados son verdaderos.

```js
console.log(true && false)
// → false
console.log(true && true)
// → true
```

El operador || representa el operador lógico or. Lo que produce es verdadero si cualquiera de los valores dados es verdadero.

```js
console.log(false || true)
// → true
console.log(false || false)
// → false
```

Not se escribe como un signo de exclamación (!). Es un operador unario que voltea el valor dado—!true produce false y !false produce true.

operadores que hemos visto hasta ahora, || tiene la menor precedencia, luego le sigue &&, luego le siguen los operadores de comparación (>, ==, y demás), y luego el resto.

El ultimo operador lógico que discutiremos no es unario, tampoco binario,
sino ternario, esto es, que opera en tres valores. Es escrito con un signo de
interrogación y dos puntos.

```js
console.log(true ? 1 : 2);
// → 1
console.log(false ? 1 : 2);
// → 2
```

#### Valores vacíos
Existen dos valores especiales, escritos como `null y undefined`, que son usados para denotar la ausencia de un valor significativo. Son en si mismos valores, pero no traen consigo información.

Cuando un operador es aplicado al tipo de valor “incorrecto”, JavaScript silenciosamente convertirá ese valor al tipo que necesita, utilizando una serie de reglas que frecuentemente no dan el resultado que quisieras o esperarías. Esto es llamado `coercion de tipo`.

Este comportamiento es frecuentemente util. Cuando queremos probar si un valor tiene un valor real en vez de null o undefined, puedes compararlo con null usando el operador == (o !=).

#### Corto circuito de operadores lógicos
Esto tiene el efecto esperado cuando los valores son Booleanos, pero se comporta de una forma algo análoga con valores de otros tipos.

console.log(null || "usuario")
// → usuario
console.log("Agnes" || "usuario")
// → Agnes

### EStructura de programa
Un fragmento de código que produce un valor se llama una expresión. Cada valor que se escribe literalmente (como 22 o "psicoanálisis") es una expresión.

Si una expresión corresponde al fragmento de una oración, una declaración en JavaScript corresponde a una oración completa.

Un programa es una lista de declaraciones

El tipo más simple de declaración es una expresión con un punto y coma después ella. Esto es un programa:
>1;
>!false;

Para atrapar y mantener valores, JavaScript proporciona una cosa llamada vinculación, o variable

Vinculaciones

La palabra especial (palabra clave) `let` indica que esta oración va a definir una vinculación. Le sigue el nombre de la vinculación y, si queremos darle un valor inmediatamente, un operador = y una expresión.

```js
let diez = 10, dos=2;
console.log(diez * diez);
// → 100
```
`var` (abreviatura de “variable”), es la forma en la que se declaraban las vinculaciones en JavaScript previo al 2015.

`const` representa una constante. Define una vinculación constante, que apunta al mismo valor por el tiempo que viva.

```js
var nombre = "Ayda";
const saludo = "Hola ";
console.log(saludo + nombre);
// → Hola Ayda
```

#### Nombres de vinculaciones
Los nombres de las vinculaciones pueden ser cualquier palabra. Los dígitos pueden ser parte de los nombres de las vinculaciones pueden—catch22 es un nombre válido, por ejemplo—pero el nombre no debe comenzar con un dígito.
El nombre de una vinculación puede incluir signos de dólar ($) o caracteres de subrayado (_), pero no otros signos de puntuación o caracteres especiales

> La lista completa de palabras clave y palabras reservadas es bastante larga

La colección de vinculaciones y sus valores que existen en un momento dado se llama `entorno`. Cuando se inicia un programa, est entorno no está vacío. Siempre contiene vinculaciones que son parte del estándar del lenguaje

Una función es una pieza de programa envuelta en un valor.Dichos valores pueden ser aplicados para ejecutar el programa envuelto.

Ejecutar una función tambien se conoce como invocarla, llamarla, o aplicarla.

La ejecución condicional se crea con la palabra clave if en JavaScript. En el caso simple, queremos que se ejecute algún código si, y solo si, una cierta
condición se cumple.

``` Javascript
let elNumero = Number(prompt("Elige un numero"));
if (!Number.isNaN(elNumero)) {
console.log("Tu número es la raiz cuadrada de " +
elNumero * elNumero);
}
else {
console.log("Ey. Por qué no me diste un número?");
}

```
Necesitamos es una forma de ejecuta una pieza de código multiples veces. Esta forma de flujo de control es llamada un ciclo (o “loop”):

``` Javascript
let numero = 0;
while (numero <= 12) {
console.log(numero);
numero = numero + 2;
}
// → 0
// → 2
// … etcetera
```

### Funciones

``` Javascript
prompt("Introducir contraseña"); //crea una caja de dialogo
console.log("salida") //para dar salida a los valores.

console.log(Math.max(2, 4));
// devuelve el mayor de ellos.

Number("7") // convierte en una numero

Number.isNaN("4") // función estándar de JavaScript que retorna true solo si el argumento que se le da es NaN.
```
>>>>>>> a0ef526ddff5cd7d082e15aa0943c12279c510c2
